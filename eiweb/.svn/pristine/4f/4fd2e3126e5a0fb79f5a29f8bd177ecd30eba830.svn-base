package skt.eiweb.file;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import java.util.stream.Stream;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.util.FileSystemUtils;
import org.springframework.web.multipart.MultipartFile;

import skt.eiweb.authority.AuthorityService;
import skt.eiweb.authority.model.User;
import skt.eiweb.base.EIProperties;
import skt.eiweb.file.mapper.FileMapper;
import skt.eiweb.file.model.File;
import skt.eiweb.file.model.FileDto;
import skt.eiweb.model.ModelService;
import skt.eiweb.model.mapper.ModelMapper;
import skt.eiweb.model.model.Model;
import skt.eiweb.model.model.ModelDto;
import skt.eiweb.utils.FileUtil;

/**
 * ================================================================================
 * @Project      : eiweb
 * @Package      : skt.eiweb.file
 * @Filename     : FileServiceImpl.java
 * 
 * All rights reserved. No part of this work may be reproduced, stored in a
 * retrieval system, or transmitted by any means without prior written
 * permission of SKT corp.
 * 
 * Copyright(c) 2020 SKT corp. All rights reserved
 * =================================================================================
 *  No     DATE              Description
 * =================================================================================
 *  1.0	   2020. 9. 29.      Initial Coding & Update
 * =================================================================================
 */
@Service
public class FileServiceImpl implements FileService {

	private static final Logger logger = LogManager.getLogger(FileServiceImpl.class);

	@Autowired
	private AuthorityService service;

	@Autowired
	private ModelService modelService;

	@Autowired
	private FileMapper mapper;

	@Autowired
	private ModelMapper modelMapper;

	@Autowired
	private EIProperties props;

	private Path root = null;

	@Override
	public void init() {
		boolean isSuccess = FileUtil.makeDirectory(root);
		if (!isSuccess) {
			throw new RuntimeException("could not initialize upload directory!!");
		}
	}

	@Override
	public void init(String path) {
		root = Paths.get(path);
		this.init();
	}

	/**
	 * 파일 저장
	 */
	@Override
	public File save(MultipartFile file) {
		logger.info("FileServiceImpl.save");
		File fileVo = new File();

		try {
			// 파일코드 생성
			String code = UUID.randomUUID().toString().replaceAll("-", "").toUpperCase();
			if (Files.exists(this.root.resolve(code))) {
				code = UUID.randomUUID().toString().replaceAll("-", "").toUpperCase();
			}

			// 파일 정보(사이즈,확장자,파일명)
			String ext = "";
			String filename = file.getOriginalFilename();
			if (props.getMaxFileNameLen() < filename.length()) {
				throw new RuntimeException("파일명 길이가 너무깁니다. (길이제한 : " + props.getMaxFileNameLen() + ")");
			}
			if (file.getOriginalFilename().indexOf(".") > -1) {
				ext = filename.substring(filename.lastIndexOf(".") + 1, filename.length());
			}
			// property : eiconfig.uploadextensions 설정되어 있는 업로드 가능한 확장자 체크
			if (!chkUploadExt(ext)) {
				throw new RuntimeException("업로드 가능하지 않는 확장자 입니다. : " + ext);
			}

			// 사용자 정보 가져오기
			Authentication auth = SecurityContextHolder.getContext().getAuthentication();
			User usr = new User();
			usr.setPassword(auth.getCredentials().toString());
			if (props.isDeveloping()) {
				usr.setUserId("admin");
			} else {
				usr = service.getUserInfoByPw(usr);
			}

			// 파일 저장
			Files.copy(file.getInputStream(), this.root.resolve(code));

			// 파일 정보 저장
			fileVo.setFileCode(code);
			fileVo.setFileName(file.getOriginalFilename());
			fileVo.setFileExt(ext);
			fileVo.setFileSize(Long.toString(file.getSize()));
			fileVo.setUserId(usr.getUserId());
			mapper.insertFile(fileVo);
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}

		return fileVo;
	}

	private boolean chkUploadExt(String ext) {
		boolean ret = false;
		String[] exts = props.getUploadextensions().split(",");

		for (int i = 0; i < exts.length; i++) {
			if (exts[i].toLowerCase().equals(ext.toLowerCase()))
				ret = true;
		}

		return ret;
	}

	@SuppressWarnings({
		"rawtypes", "unchecked"
	})
	@Override
	public HashMap load(String fileCode) {
		HashMap ret = new HashMap();

		try {
			File fileVo = new File();
			fileVo.setFileCode(fileCode);
			List<FileDto> list = mapper.selectFile(fileVo);
			FileDto dto = null;
			for (int i = 0; i < list.size(); i++) {
				dto = list.get(i);
			}
			Path file = root.resolve(fileCode);
			Resource resource = new UrlResource(file.toUri());
			ret.put("resource", resource);
			ret.put("file", dto);

			if (resource.exists() || resource.isReadable()) {
				return ret;
			} else {
				throw new RuntimeException("Could not read the file!");
			}
		} catch (MalformedURLException e) {
			throw new RuntimeException("Error: " + e.getMessage());
		} catch (Exception e) {
			throw new RuntimeException("Error: " + e.getMessage());
		}
	}

	@Override
	public void deleteAll() {
		FileSystemUtils.deleteRecursively(root.toFile());
	}

	@Override
	public void deleteAll(String path) {
		root = Paths.get(path);
		this.deleteAll();
	}

	@Override
	public Stream<Path> loadAll() {
		try {
			return Files.walk(this.root, 1).filter(path -> !path.equals(this.root)).map(this.root::relativize);
		} catch (IOException e) {
			throw new RuntimeException("Could not load the files!");
		}
	}

	/**
	 * 업로드된 파일을 모델파일 정보로 변환 및 저장(매핑)
	 */
	@Override
	public void modelUploaded(String modelId, String[] fileCodes) throws Exception {
		String fileCode;
		FileDto fileVo = null;
		Model model = modelService.getModelInfo(modelId);
		String version = "1";

		if (model != null) {
			version = model.getVersion();
		}

		for (int i = 0; i < fileCodes.length; i++) {
			fileCode = fileCodes[i];

			// 파일 정보 가져오기
			fileVo = new FileDto();
			FileDto file = null;
			fileVo.setFileCode(fileCode);
			List<FileDto> list = mapper.selectFile(fileVo);
			for (int j = 0; j < list.size(); j++) {
				file = list.get(j);
			}

			// 파일코드(저장 파일명)
			String newFileCode = file.getFileName().replace("." + file.getFileExt(), "") + "." + version + "." + file.getFileExt();

			// 파일 정보 업데이트(코드 변경)
			FileDto updFileVo = new FileDto();
			updFileVo.setFileCode(file.getFileCode());
			updFileVo.setModelId(modelId);
			updFileVo.setModelVersion(version);
			updFileVo.setNewFileCode(newFileCode);
			mapper.updateFile(updFileVo);

			// 모델아이디 하위로 파일 이동
			// 모델아이디 디렉토리 유무 확인 및 없으면 생성
			Path modelPath = Paths.get(props.getUploadpath() + "/" + modelId);
			Path preFilePath = Paths.get(props.getUploadpath() + "/" + file.getFileCode());
			Path movePath = Paths.get(props.getUploadpath() + "/" + modelId + "/" + newFileCode);
			if (Files.notExists(modelPath)) {
				Files.createDirectory(modelPath);
			}
			if (Files.exists(preFilePath)) {
				if (Files.exists(movePath))
					Files.delete(movePath);
				Files.move(preFilePath, movePath);
			}
		}
	}

	/**
	 * 파일 삭제
	 */
	@Override
	public int delete(String fileCode) throws Exception {
		Path pfile = root.resolve(fileCode);
		if (Files.exists(pfile)) {
			Files.delete(pfile);
		}

		FileDto file = new FileDto();
		if (fileCode.indexOf("\\") > -1) {
			fileCode = fileCode.substring(fileCode.indexOf("\\") + 1, fileCode.length());
		}
		file.setFileCode(fileCode);

		return mapper.deleteFile(file);
	}

	/**
	 * 모델의 파일 삭제(모델 삭제시)
	 */
	@Override
	public int deleteByModelId(String modelId) throws Exception {
		File fileVo = new File();
		fileVo.setModelId(modelId);
		List<FileDto> list = mapper.selectFile(fileVo);
		int ret = 0;

		for (int i = 0; i < list.size(); i++) {
			ret += this.delete(list.get(i).getModelId() + "\\" + list.get(i).getFileCode());
		}
		// 폴더 삭제
		Files.delete(root.resolve(modelId));

		return ret;
	}

	/**
	 * 해당 모델의 파일리스트(최근버전)
	 */
	@Override
	public List<FileDto> getFileListByModelId(String modelId) throws Exception {
		File fileVo = new File();
		fileVo.setModelId(modelId);

		return mapper.selectFile(fileVo);
	}

	/**
	 * 해당 모델의 파일리스트(버전 지정)
	 */
	@Override
	public List<FileDto> getFileListByModelId(String modelId, String version) throws Exception {
		FileDto fileVo = new FileDto();
		fileVo.setModelId(modelId);
		fileVo.setVersion(version);

		return mapper.selectFile(fileVo);
	}

	/**
	 * 저장전 업로드된 파일 리스트
	 */
	@Override
	public String[] newFileCodes(FileDto dto) throws Exception {
		List<FileDto> list = mapper.selectNewFileCodes(dto);
		FileDto file;
		String[] ret = new String[list.size()];

		for (int i = 0; i < list.size(); i++) {
			file = list.get(i);
			ret[i] = file.getFileCode();
		}

		return ret;
	}

	/**
	 * 모델 수정시 기존 파일이 제거되면 파일을 삭제처리
	 */
	@Override
	public int refreshFileCodes(FileDto dto) throws Exception {
		int ret = 0;
		List<FileDto> list = mapper.selectDelFileCodes(dto);
		FileDto delFile;

		for (int i = 0; i < list.size(); i++) {
			delFile = list.get(i);
			ret += delete(delFile.getModelId() + "\\" + delFile.getFileCode());
		}

		return ret;
	}

	/**
	 * 현재 파일리스트 기준 기존 모델 파일 버전 업데이트(복사)
	 */
	@Override
	public int updateVersionFiles(FileDto dto) throws Exception {
		int ret = 0;
		FileDto file = null;
		FileDto fDto = new FileDto();
		fDto.setModelId(dto.getModelId());
		fDto.setFileCodes(dto.getFileCodes());

		// 버전 업할 파일 리스트
		List<FileDto> list = mapper.selectFile(fDto);
		Path p = null;
		Path vuFile = null;
		String versionUpFileCode = "";

		// 버전 가져오기
		Model model = new Model();
		ModelDto mDto = null;
		model.setModelId(dto.getModelId());
		List<ModelDto> mList = modelMapper.selectModel(model);
		for (int i = 0; i < mList.size(); i++) {
			mDto = mList.get(i);
		}
		String version = mDto.getVersion();

		// 사용자 정보 가져오기
		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		User usr = new User();
		usr.setPassword(auth.getCredentials().toString());
		if (props.isDeveloping()) {
			usr.setUserId("admin");
		} else {
			usr = service.getUserInfoByPw(usr);
		}

		for (int i = 0; i < list.size(); i++) {
			file = list.get(i);
			p = Paths.get(props.getUploadpath() + "/" + file.getModelId() + "/" + file.getFileCode());
			versionUpFileCode = file.getFileName().replace(file.getFileExt(), "") + version + "." + file.getFileExt();
			vuFile = Paths.get(props.getUploadpath() + "/" + file.getModelId() + "/" + versionUpFileCode);
			file.setUserId(usr.getUserId());
			file.setFileCode(versionUpFileCode);
			file.setModelVersion(version);
			mapper.insertFile(file);
			try {
				if (Files.exists(p))
					Files.copy(p, vuFile);
			} catch (Exception e) {
				System.out.println(e.getMessage());
			}
		}
		ret = list.size();

		return ret;
	}

	/**
	 * 미매핑 파일 삭제
	 */
	@Override
	public int removeNotMappingFiles() throws Exception {
		int ret = -1;
		List<FileDto> list = mapper.notMappingFiles();
		FileDto file;

		for (int i = 0; i < list.size(); i++) {
			file = list.get(i);
			this.delete(file.getFileCode());
		}

		return ret;
	}

	/**
	 * 모델 파일 저장
	 */
	public File modelFileSave(MultipartFile file) {
		File fileVo = new File();

		try {
			String saveFileName = file.getOriginalFilename();
			String ext = "";
			if (file.getOriginalFilename().indexOf(".") > -1) {
				ext = saveFileName.substring(saveFileName.lastIndexOf(".") + 1, saveFileName.length());
			}
			saveFileName = saveFileName.replaceAll("." + ext, "");
			Files.copy(file.getInputStream(), this.root.resolve(saveFileName));
		} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}

		return fileVo;
	}

}
